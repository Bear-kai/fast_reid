1. 视频相关说明，参见初测文件夹中的readme-1.txt；


2. 本次视频中对比了3种去重方式，分别为逻辑1、逻辑2、基于ReID（视频左上角有标明）；
	
	逻辑1：只要检测到bbox数目的上升沿就报警，具体见流程图；

	逻辑2：检测到bbox数目的上升沿后bbox数目维持连续N个处理帧就报警，具体见流程图；
			实际记录的bbox数目变化和报警情况，见test.txt；
	
	ReID：逻辑较为复杂，参见初测文件夹中readme-1中的附录1；
	
	
3. 测试结果(真实报警<10)：	逻辑1 ：逻辑2 ：基于ReID
	[speed00_T94第7800帧]	 69   ：  38  ：  24 
	[speed05_T94第5400帧]    110  ：  45  ：  35
	[speed10_T94第8500帧]    125  ：  61  :   58
	
	
4. 总结
	1）如此前邮件所述，ReID去重暂时最优，但实用性能不够&速度慢&耗额外计算资源，项目上终止该方案；
	
	2）从逻辑1到逻辑2，添加连续帧约束后，误报已大幅降低；
	
	3）逻辑1和2仅作为两个例子，后续机器人的兄弟可在实测时多分析误报情形，针对性设计更多策略；
	  后续可能的策略：
	   a.站在应用场景中思考，调整合适的检测阈值（score超过多少才认为真的检测到行人），平衡漏检和误检；
	   b.对于人少的情形，引入bbox坐标，计算框关联（注：IOU是两个框的交集面积除以并集面积）；
	     比如第1帧在位置A有bbox1，第2帧无检测框，第3帧在位置B有bbox2，
		 若A和B很近，可通过计算bbox1和bbox2的IOU判断：IOU>阈值则认为第2帧漏检了，bbox_num的1,0,1应修正为1,1,1；
	   c. 若检测算法的处理帧率提升，且额外提供算力，有可能引入基于跟踪的去重算法（孙博的实习生陈杜煜做过探索）
		 
	4）当然，加入的策略越多/越复杂，系统稳定性可能越差，此时可能得再次回到应用场景中，思考更上一层的产品逻辑。
	     比如是为及时报警，还是为记录现场事后查阅，or其他？
	     比如若为及时报警，则能否不论检测到多少行人，报警1次后的eg.10min内就关闭报警系统了，因保安在现场处理可能就得10min呢...
	   
	   